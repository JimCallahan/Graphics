package org.scalagfx.math

//--------------------------------------------------------------------------------------------------
//   P O S   2 D                                                                             
//--------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------
//  Supported Subset of Operations:                                                         
//                                                      
//    P + S -> P      P - S -> P      P * S -> P      P / V -> P       
//    V + S -> V      V - S -> V      V * S -> V      V / S -> V           
//
//       ---          P - P -> V         ---             ---                                 
//    P + V -> P      P - V -> P      P * V -> P      P / V -> P
//    V + V -> V      V - V -> V      V * V -> V      V / V -> V 
//                                                                                          
//  S = Scalar(Double), P = Position(Pos2d), V = Vector(Vec2d)                              
//--------------------------------------------------------------------------------------------------

/** Companion object for Pos2d. */
object Pos2d 
{
  //------------------------------------------------------------------------------------------------
  //   C R E A T I O N                                                                      
  //------------------------------------------------------------------------------------------------

  /** Create a new position from components. */
  def apply(x: Double, y: Double) = 
    new Pos2d(x, y)

  /** Create a new position in which all components are the same scalar value. */ 
  def apply(s: Double) = 
    new Pos2d(s, s) 
 
  /** The origin. */
  val origin: Pos2d = 
    Pos2d(0.0)
  

  //------------------------------------------------------------------------------------------------
  //   C O M P A R I S O N                                                                  
  //------------------------------------------------------------------------------------------------

  /** The component-wise comparison of whether two positions are within a given epsilon. */ 
  def equiv(a: Pos2d, b: Pos2d, epsilon: Double): Boolean = 
    a.equiv(b, epsilon) 
  
  /** The component-wise comparison of whether two positions are within a type specific
    * epsilon. */ 
  def equiv(a: Pos2d, b: Pos2d): Boolean = 
    (a equiv b)
  
  /** The component-wise minimum of two positions. */
  def min(a: Pos2d, b: Pos2d): Pos2d = 
    compwise(a, b, scala.math.min(_, _)) 
  
  /** The component-wise maximum of two positions. */
  def max(a: Pos2d, b: Pos2d): Pos2d = 
    compwise(a, b, scala.math.max(_, _)) 
  			
  
  //------------------------------------------------------------------------------------------------
  //   I N T E R P O L A T I O N                                                            
  //------------------------------------------------------------------------------------------------

  /** Linearly interpolate between two positions. */
  def lerp(a: Pos2d, b: Pos2d, t: Double): Pos2d = 
    compwise(a, b, Scalar.lerp(_, _, t)) 
  
  /** Smooth-step interpolate between two positions. */
  def smoothlerp(a: Pos2d, b: Pos2d, t: Double): Pos2d = 
    compwise(a, b, Scalar.smoothlerp(_, _, t)) 


  //------------------------------------------------------------------------------------------------
  //   U T I L I T Y                                                                        
  //------------------------------------------------------------------------------------------------

  /** Create a position who's components are generated by applying the given binary operator
    * to each of the corresponding components of the given two positions. */ 
  def compwise(a: Pos2d, b: Pos2d, f: (Double, Double) => Double): Pos2d = 
    Pos2d(f(a.x, b.x), f(a.y, b.y))

}

/** An immutable 2-dimensional vector of Double element type used to represent a position in
  * space for use in computational geometry applications.
  *
  * This is not meant to be a general purpose vector, but rather to only defined the limited
  * set of operations which make geometric sense.  This allows Scala type checking to catch
  * many of the most common errors where scalars, vectors or positions are being accidently
  * used in a way that is geometrically meaningless. */ 
class Pos2d(val x: Double, val y: Double) extends Vector2dLike
{
  type Self = Pos2d

  //------------------------------------------------------------------------------------------------
  //   C O M P O N E N T   O P S                                                            
  //------------------------------------------------------------------------------------------------

  /** A copy of this position in which the X component has been replaced with the given
    * value. */ 
  def newX(v: Double): Pos2d = 
    Pos2d(v, y)
  
  /** A copy of this position in which Y component has been replaced with the given value. */ 
  def newY(v: Double): Pos2d = 
    Pos2d(x, v)
  
  /** A copy of this position in which the component with the given index as been replaced. */
  def newComp(i: Int, v: Double) = 
    i match {
      case 0 => Pos2d(v, y)
      case 1 => Pos2d(x, v)
      case _ => throw new IllegalArgumentException("Invalid index (" + i + ")!")
    }


  //------------------------------------------------------------------------------------------------
  //   U N A R Y   O P S                                                                    
  //------------------------------------------------------------------------------------------------

  /** A position reflected about the origin. */
  def negated: Pos2d = Pos2d(-x, -y)

		    
  //------------------------------------------------------------------------------------------------
  //   O P E R A T O R S                                                                    
  //------------------------------------------------------------------------------------------------

  /** The addition of a scalar to all components of this position. */ 
  def + (scalar: Double): Pos2d = Pos2d(x+scalar, y+scalar) 

  /** The component-wise addition of a vector with this position. */ 
  def + (that: Vec2d): Pos2d = Pos2d(x+that.x, y+that.y)
  

  /** The subtraction of a scalar value to all components of this position. */ 
  def - (scalar: Double): Pos2d = Pos2d(x-scalar, y-scalar)
  
  /** The component-wise subtraction a vector from this position. */ 
  def - (that: Vec2d): Pos2d = Pos2d(x-that.x, y-that.y)

  /** The vector from the given position to this position. */ 
  def - (that: Pos2d): Vec2d = Vec2d(x-that.x, y-that.y)


  /** The product of a scalar value with all components of this position. */ 
  def * (scalar: Double): Pos2d = Pos2d(x*scalar, y*scalar)

  /** The component-wise multiplication of a vector with this position. */ 
  def * (that: Vec2d): Pos2d = Pos2d(x*that.x, y*that.y)
  
  
  /** The quotient of dividing all components of this position by a scalar value. */ 
  def / (scalar: Double): Pos2d = Pos2d(x/scalar, y/scalar)

  /** The component-wise division of this position by a vector. */ 
  def / (that: Vec2d): Pos2d = Pos2d(x/that.x, y/that.y)


  //------------------------------------------------------------------------------------------------
  //   C O M P A R I S O N                                                                  
  //------------------------------------------------------------------------------------------------

  /** Compares this position to the specified value for equality. */
  override def equals(that: Any): Boolean = 
    that match {
      case that: Pos2d => 
        (that canEqual this) && (x == that.x) && (y == that.y)
      case _ => false
    }

  /** A method that should be called from every well-designed equals method that is open
    * to be overridden in a subclass. */
  def canEqual(that: Any): Boolean = 
    that.isInstanceOf[Pos2d]

  /** Returns a hash code value for the object. */
  override def hashCode: Int = 
    43 * (41 + x.##) + y.##


  //------------------------------------------------------------------------------------------------
  //   U T I L I T Y                                                                        
  //------------------------------------------------------------------------------------------------

  /** Tests whether the given predicate holds true for all of the corresponding components
    * of this and the given position. */ 
  def forall(that: Pos2d)(p: (Double, Double) => Boolean): Boolean = 
    p(x, that.x) && p(y, that.y)

  /** Tests whether the given predicate holds true for any of the corresponding components
    * of this and the given position. */ 
  def forany(that: Pos2d)(p: (Double, Double) => Boolean): Boolean = 
    p(x, that.x) || p(y, that.y)

  /** Builds a new position by applying a function to each component of this position. */
  def map(f: (Double) => Double): Pos2d = 
    Pos2d(f(x), f(y))


  //------------------------------------------------------------------------------------------------
  //   C O N V E R S I O N                                                                  
  //------------------------------------------------------------------------------------------------

  /** Convert to a string representation. */
  override def toString() = 
    "Pos2d(%.2f, %.2f)".format(x, y)

}

