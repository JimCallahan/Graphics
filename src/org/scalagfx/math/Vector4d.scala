// Copyright 2011-2012 James Michael Callahan
// See LICENSE-2.0 file for licensing information.

package org.scalagfx.math

import java.nio._

//--------------------------------------------------------------------------------------------------
//   V E C T O R   4 D                                                                     
//--------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------
//  Supported Operations:                                                      
//                                                          
//    V + S -> V      V - S -> V      V * S -> V      V / S -> V           
//
//    V + V -> V      V - V -> V      V * V -> V      V / V -> V 
//                                                                                       
//  S = Scalar(Double), V = Vector(Vector4d)                           
//--------------------------------------------------------------------------------------------------

/** Companion object for Vector4d. */
object Vector4d 
{
  //------------------------------------------------------------------------------------------------
  //   C R E A T I O N                                                                     
  //------------------------------------------------------------------------------------------------

  /** Create a new vector with all components set to the given value. */
  def apply(s: Double) = 
    new Vector4d(s, s, s, s) 

  /** Create a new vector from components. */
  def apply(x: Double, y: Double, z: Double, w: Double) = 
    new Vector4d(x, y, z, w)


  /** A unit length vector along the X-axis. */ 
  val unitX: Vector4d = 
    Vector4d(1.0, 0.0, 0.0, 0.0)

  /** A unit length vector along the Y-axis. */ 
  val unitY: Vector4d = 
    Vector4d(0.0, 1.0, 0.0, 0.0) 

  /** A unit length vector along the Z-axis. */ 
  val unitZ: Vector4d = 
    Vector4d(0.0, 0.0, 1.0, 0.0) 

  /** A unit length vector along the W-axis. */ 
  val unitW: Vector4d = 
    Vector4d(0.0, 0.0, 0.0, 1.0) 


  //------------------------------------------------------------------------------------------------
  //   C O M P A R I S O N                                                                  
  //------------------------------------------------------------------------------------------------

  /** The component-wise comparison of whether two vectors are within a given epsilon. */ 
  def equiv(a: Vector4d, b: Vector4d, epsilon: Double): Boolean = 
    a.equiv(b, epsilon) 
  
  /** The component-wise comparison of whether two vectors are within a type specific
    * epsilon. */ 
  def equiv(a: Vector4d, b: Vector4d): Boolean = 
    (a equiv b)
  
  /** The component-wise minimum of two vectors. */
  def min(a: Vector4d, b: Vector4d): Vector4d = 
    compwise(a, b, scala.math.min(_, _)) 
  
  /** The component-wise maximum of two vectors. */
  def max(a: Vector4d, b: Vector4d): Vector4d = 
    compwise(a, b, scala.math.max(_, _)) 
  			
  
  //------------------------------------------------------------------------------------------------
  //   I N T E R P O L A T I O N                                                           
  //------------------------------------------------------------------------------------------------

  /** Linearly interpolate between two vectors. */
  def lerp(a: Vector4d, b: Vector4d, t: Double): Vector4d = 
    compwise(a, b, Scalar.lerp(_, _, t)) 
  
  /** Smooth-step interpolate between two vectors. */
  def smoothlerp(a: Vector4d, b: Vector4d, t: Double): Vector4d = 
    compwise(a, b, Scalar.smoothlerp(_, _, t)) 


  //------------------------------------------------------------------------------------------------
  //   U T I L I T Y                                                                        
  //------------------------------------------------------------------------------------------------

  /** Create a vector who's components are generated by applying the given binary operator
    * to each of the corresponding components of the given two vectors. */ 
  def compwise(a: Vector4d, b: Vector4d, f: (Double, Double) => Double): Vector4d = 
    Vector4d(f(a.x, b.x), f(a.y, b.y), f(a.z, b.z), f(a.w, b.w)) 
}

/** An immutable 4-dimensional vector of Double element type used to represent homogeneous vectors
  * for use in computational geometry applications. */ 
class Vector4d(val x: Double, val y: Double, val z: Double, val w: Double) extends Vector4dLike
{
  type Self = Vector4d
  
  //------------------------------------------------------------------------------------------------
  //   C O M P O N E N T   O P S                                                            
  //------------------------------------------------------------------------------------------------

  /** A copy of this vector in which the X component has been replaced with the given
    * value. */ 
  def newX(v: Double): Vector4d = 
    Vector4d(v, y, z, w)
  
  /** A copy of this vector in which the Y component has been replaced with the given
    * value. */ 
  def newY(v: Double): Vector4d = 
    Vector4d(x, v, z, w)
  
  /** A copy of this vector in which the Z component has been replaced with the given
    * value. */ 
  def newZ(v: Double): Vector4d = 
    Vector4d(x, y, v, w)
  
  /** A copy of this vector in which the W component has been replaced with the given
    * value. */ 
  def newW(v: Double): Vector4d = 
    Vector4d(x, y, z, v)
  
  /** A copy of this vector in which the component with the given index as been replaced. */
  def newComp(i: Int, v: Double) = 
    i match {
      case 0 => Vector4d(v, y, z, w)
      case 1 => Vector4d(x, v, z, w)
      case 2 => Vector4d(x, y, v, w)  
      case 3 => Vector4d(x, y, z, v)
      case _ => throw new IllegalArgumentException("Invalid index (" + i + ")!")
    }

  
  //------------------------------------------------------------------------------------------------
  //   U N A R Y   O P S                                                                    
  //------------------------------------------------------------------------------------------------

  /** A vector of identical magnitude but opposite direction. */
  def negated: Vector4d = Vector4d(-x, -y, -z, -w)

  /** The length (magnitude) of this vector squared. */
  def lengthSq: Double = dot(this)

  /** The length (magnitude) of this vector. */
  def length: Double = scala.math.sqrt(lengthSq)

  /** A vector of identical direction but unit length. */
  def normalized: Self = this * (1.0 / length) 

  /** A 3-dimensional vector in which XYZ components of this vector have been divided by W. */ 
  def homogenized: Vector3d = 
    if(!Scalar.equiv(w, 0.0)) Vector3d(x/w, y/w, z/w) 
    else throw new UnsupportedOperationException("The W component of this vector was zero!")


  					    
  //------------------------------------------------------------------------------------------------
  //   O P E R A T O R S                                                                    
  //------------------------------------------------------------------------------------------------

  /** The addition of a scalar value to all components of this vector. */ 
  def + (scalar: Double): Vector4d = Vector4d(x+scalar, y+scalar, z+scalar, w+scalar) 

  /** The component-wise addition of this vector with another vector. */ 
  def + (that: Vector4d): Vector4d = Vector4d(x+that.x, y+that.y, z+that.z, w+that.w)
  

  /** The subtraction of a scalar value from all components of this vector. */ 
  def - (scalar: Double): Vector4d = Vector4d(x-scalar, y-scalar, z-scalar, w-scalar) 
  
  /** The component-wise subtraction of another vector from this vector. */ 
  def - (that: Vector4d): Vector4d = Vector4d(x-that.x, y-that.y, z-that.z, w-that.w)


  /** The product of a scalar value with all components of this vector. */ 
  def * (scalar: Double): Vector4d = Vector4d(x*scalar, y*scalar, z*scalar, w*scalar) 

  /** The component-wise multiplication of this vector with another vector. */ 
  def * (that: Vector4d): Vector4d = Vector4d(x*that.x, y*that.y, z*that.z, w*that.w)


  /** The quotient of dividing all components of this vector by a scalar value. */ 
  def / (scalar: Double): Vector4d = Vector4d(x/scalar, y/scalar, z/scalar, w/scalar) 

  /** The component-wise division of this vector by another vector. */ 
  def / (that: Vector4d): Vector4d = Vector4d(x/that.x, y/that.y, z/that.z, w/that.w)


  /** The dot-product of this and another vector. */
  def dot(that: Vector4d): Double = 
    x*that.x + y*that.y + z*that.z + w*that.w

  

  //------------------------------------------------------------------------------------------------
  //   C O M P A R I S O N                                                                  
  //------------------------------------------------------------------------------------------------

  /** Compares this vector to the specified value for equality. */
  override def equals(that: Any): Boolean = 
    that match {
      case that: Vector4d => 
        (that canEqual this) && (x == that.x) && (y == that.y) && (z == that.z) && (w == that.w)
      case _ => false
    }

  /** A method that should be called from every well-designed equals method that is open
    * to be overridden in a subclass. */
  def canEqual(that: Any): Boolean = 
    that.isInstanceOf[Vector4d]

  /** Returns a hash code value for the object. */
  override def hashCode: Int = 
    53 * (47 * (43 * (41 + x.##) + y.##) + z.##) + w.##


  //------------------------------------------------------------------------------------------------
  //   U T I L I T Y                                                                        
  //------------------------------------------------------------------------------------------------

  /** Tests whether the given predicate holds true for all of the corresponding components
    * of this and the given vector. */ 
  def forall(that: Vector4d)(p: (Double, Double) => Boolean): Boolean = 
    p(x, that.x) && p(y, that.y) && p(z, that.z) && p(w, that.w)

  /** Tests whether the given predicate holds true for any of the corresponding components
    * of this and the given vector. */ 
  def forany(that: Vector4d)(p: (Double, Double) => Boolean): Boolean = 
    p(x, that.x) || p(y, that.y) || p(z, that.z) || p(w, that.w)

  /** Builds a new vector by applying a function to each component of this vector. */
  def map(f: (Double) => Double): Vector4d = 
    Vector4d(f(x), f(y), f(z), f(w))


  //------------------------------------------------------------------------------------------------
  //   C O N V E R S I O N                                                                  
  //------------------------------------------------------------------------------------------------

  /** Convert to a string representation. */
  override def toString() = 
    "Vector4d(%.2f, %.2f, %.2f, %.2f)".format(x, y, z, w)

}

